-- Character list entry format: character: {pressed,  shift+pressed}

TotalCharList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
    ['F1'] = {'F1','F1'},
    ['F2'] = {'F2','F2'},
    ['F3'] = {'F3','F3'},
    ['F4'] = {'F4','F4'},
    ['F5'] = {'F5','F5'},
    ['F6'] = {'F6','F6'},
    ['F7'] = {'F7','F7'},
    ['F8'] = {'F8','F8'},
    ['F9'] = {'F9','F9'},
    ['F10'] = {'F10','F10'},
    ['F11'] = {'F11','F11'},
    ['F12'] = {'F12','F12'},
    ['G'] = {'g','G'},
    ['H'] = {'h','H'},
    ['I'] = {'i','I'},
    ['J'] = {'j','J'},
    ['K'] = {'k','K'},
    ['L'] = {'l','L'},
    ['M'] = {'m','M'},
    ['N'] = {'n','N'},
    ['O'] = {'o','O'},
    ['P'] = {'p','P'},
    ['Q'] = {'q','Q'},
    ['R'] = {'r','R'},
    ['S'] = {'s','S'},
    ['T'] = {'t','T'},
    ['U'] = {'u','U'},
    ['V'] = {'v','V'},
    ['W'] = {'w','W'},
    ['X'] = {'x','X'},
    ['Y'] = {'y','Y'},
    ['Z'] = {'z','Z'},
    ['alt'] = {'alt','alt'},
    ['backslash'] = {'\\','|'},
    ['backspace'] = {'backspace','backspace'},
    ['capslock'] = {'capslock','capslock'},
    ['comma'] = {',','<'},
    ['control'] = {'control','control'},
    ['delete'] = {'delete','delete'},
    ['down'] = {'down','down'},
    ['end'] = {'end','end'},
    ['enter'] = {'enter','enter'},
    ['escape'] = {'escape','escape'},
    ['home'] = {'home','home'},
    ['left'] = {'left','left'},
    ['leftbracket'] = {'[','{'},
    ['leftclick'] = {'leftclick','leftclick'},
    ['minus'] = {'-','_'},
    ['numpad*'] = {'*','*'},
    ['numpad+'] = {'+','+'},
    ['numpad-'] = {'-','-'},
    ['numpad.'] = {'.','.'},
    ['numpad/'] = {'/','/'},
    ['numpad0'] = {'0','0'},
    ['numpad1'] = {'1','1'},
    ['numpad2'] = {'2','2'},
    ['numpad3'] = {'3','3'},
    ['numpad4'] = {'4','4'},
    ['numpad5'] = {'5','5'},
    ['numpad6'] = {'6','6'},
    ['numpad7'] = {'7','7'},
    ['numpad8'] = {'8','8'},
    ['numpad9'] = {'9','9'},
    ['period'] = {'.','>'},
    ['plus'] = {'=','+'},
    ['quote'] = {"'",'"'},
    ['right'] = {'right','right'},
    ['rightbracket'] = {']','}'},
    ['rightclick'] = {'rightclick','rightclick'},
    ['semicolon'] = {';',':'},
    ['shift'] = {'shift','shift'},
    ['slash'] = {'/','?'},
    ['space'] = {' ',' '},
    ['tab'] = {'	','	'},
    ['tilde'] = {'`','~'},
    ['up'] = {'up','up'},
}

LetterList = {
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
    ['G'] = {'g','G'},
    ['H'] = {'h','H'},
    ['I'] = {'i','I'},
    ['J'] = {'j','J'},
    ['K'] = {'k','K'},
    ['L'] = {'l','L'},
    ['M'] = {'m','M'},
    ['N'] = {'n','N'},
    ['O'] = {'o','O'},
    ['P'] = {'p','P'},
    ['Q'] = {'q','Q'},
    ['R'] = {'r','R'},
    ['S'] = {'s','S'},
    ['T'] = {'t','T'},
    ['U'] = {'u','U'},
    ['V'] = {'v','V'},
    ['W'] = {'w','W'},
    ['X'] = {'x','X'},
    ['Y'] = {'y','Y'},
    ['Z'] = {'z','Z'},
}

NumberList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
}

HexNumberList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
}

DirectionList = {
    ['up'] = {'up','up'},
    ['down'] = {'down','down'},
    ['left'] = {'left','left'},
    ['right'] = {'right','right'},
}

NumpadList = {
    ['numpad*'] = {'*','*'},
    ['numpad+'] = {'+','+'},
    ['numpad-'] = {'-','-'},
    ['numpad.'] = {'.','.'},
    ['numpad/'] = {'/','/'},
    ['numpad0'] = {'0','0'},
    ['numpad1'] = {'1','1'},
    ['numpad2'] = {'2','2'},
    ['numpad3'] = {'3','3'},
    ['numpad4'] = {'4','4'},
    ['numpad5'] = {'5','5'},
    ['numpad6'] = {'6','6'},
    ['numpad7'] = {'7','7'},
    ['numpad8'] = {'8','8'},
    ['numpad9'] = {'9','9'},
}

FunctionKeyList = {
    ['F1'] = {'F1','F1'},
    ['F2'] = {'F2','F2'},
    ['F3'] = {'F3','F3'},
    ['F4'] = {'F4','F4'},
    ['F5'] = {'F5','F5'},
    ['F6'] = {'F6','F6'},
    ['F7'] = {'F7','F7'},
    ['F8'] = {'F8','F8'},
    ['F9'] = {'F9','F9'},
    ['F10'] = {'F10','F10'},
    ['F11'] = {'F11','F11'},
    ['F12'] = {'F12','F12'},
}


-- Metamethods for charlists:

local function meta_copy(a,b)  -- makes a copy of a, also copying its metatable
    local copy = b or {}
    for k,v in pairs(a) do copy[k] = v end
    setmetatable(copy, getmetatable(a))
    return copy
end 

local function add_meta(a,b)  -- returns the union of a and b
    local copy = {}
    if type(b) == 'string' then copy[b] = TotalCharList[b]
    else for k,v in pairs(b) do copy[k] = v end end
    return meta_copy(a, copy)
end

local function sub_meta(a,b)  -- returns the difference of a and b
    local copy = meta_copy(a)
    if type(b) == 'string' then copy[b] = nil
    else for k,v in pairs(b) do copy[k] = nil end end
    return copy
end

local function mul_meta(a,b)  -- returns the intersection of a and b
    local copy = {}
    for k,v in pairs(a) do
        if b[k] then copy[k] = v end
    end
    setmetatable(copy, getmetatable(a))
    return copy
end

local function unm_meta(a)  -- returns the characters not in a
    local copy = meta_copy(TotalCharList)
    for k in pairs(a) do copy[k] = nil end
    return copy
end

for k,v in pairs({TotalCharList, LetterList, NumberList, HexNumberList, DirectionList, FunctionKeyList}) do
    setmetatable(v, {__add=add_meta, __sub=sub_meta, __mul=mul_meta, __unm=unm_meta})
end


-- Executes and prints strings like an interpreter
function exec(string)
    local func = loadstring("return " .. string)
    if func == nil then func, error = loadstring(string) end
    if func ~= nil then
        local values = {pcall(func)}
        if values[1] then
            if values[2] ~= nil then print(unpack(values, 2)) end
        else print(values[2]) end
    else print(error) end
end


-- Converts a table into a pretty string
function table_string(array, maxdepth)
    local sorted = {}
    for k,v in pairs(array) do table.insert(sorted, {tostring(k), v}) end
    table.sort(sorted, function(a,b) return a[1] < b[1] end)
    maxdepth = maxdepth or 1

    local function expand(array, target, depth)
        target = target or {}
        depth = depth or 1
        local padding = string.rep("  ", depth)
        for k,v in pairs(array) do
            if type(v) == "table" and depth < maxdepth then
                table.insert(target, padding..k..":")
                expand(v, target, depth+1)
            else
                table.insert(target, padding..k..": "..tostring(v))
            end
        end
        return target
    end

    local function extend(array1, array2)
        for i,v in ipairs(array2) do
            array1[#array1+1] = v
        end
    end

    local str_table = {}
    for i,v in ipairs(sorted) do
        local key, val = unpack(v)
        if type(val) == "table" then
            table.insert(str_table, key..": ")
            expand(val, str_table, 1)
        else
            table.insert(str_table, key..": "..tostring(val))
        end
    end

    return table.concat(str_table, "\n")
end


-- Checks if cursor is within the boundaries
local function cursorbounds(x1, y1, x2, y2, test1, test2)
    local key = input.get()
    local x, y = key["xmouse"], key["ymouse"]
    if x >= x1 and x <= x2 and y >= y1 and y <= y2 then return true
    else return false end
end


-- Performs a binary search on a sorted array
local function binsearch(array, value)
    local low, high = 1, #array
    if value < array[1] then return 0
    elseif value >= array[#array] then return #array end

    while true do
        local mid = math.floor((low + high)/2 + 0.5)
        local val1, val2 = array[mid], array[mid+1]
        if value >= val1 and value < val2 then
            return mid
        elseif value > val1 then 
            low, high = mid+1, high
        else
            low, high = low, mid-1
        end
        if low == high then return low end
    end
end



-- WIDGET MANAGER --

Widgets = {
    widgets = {},
    hover = {},
    priority = {},
    moving = {},
    selected = {},
    delete = {},

    -- Adds new widget
    new = function(self, widget)
        local i = 1
        for w in ipairs(self.widgets) do i = i + 1 end
        widget.ID = i
        self.widgets[widget.ID] = widget
        widget.del = function(self) Widgets.delete[widget.ID] = self end
        local maxp = 0
        for k,v in pairs(self.priority) do maxp = math.max(maxp, v) end
        self.priority[widget.ID] = maxp + 1
        return widget
    end,

    -- Draws all the widgets
    draw = function(self)
        self.key = input.get()
        local key, lastkey = self.key, self.lastkey
        local clicked = nil
        if key["leftclick"] and not lastkey["leftclick"] then clicked = "left"
        elseif key["rightclick"] and not lastkey["rightclick"] then clicked = "right" end
        if (key["control"] and key["shift"]) or key["delete"] then 
            key["leftclick"], key["rightclick"] = nil, nil 
        end

        for _,widget in pairs(self.delete) do self:del(widget) end
        
        local sorted_widgets = {}
        for ID in pairs(self.widgets) do table.insert(sorted_widgets, ID) end
        table.sort(sorted_widgets, function(a,b) return self.priority[a] < self.priority[b] end)
        
        if clicked then
            local selected = nil
            for _,ID in ipairs(sorted_widgets) do
                local widget = self.widgets[ID]
                widget.selected = nil
                self.selected[ID] = nil
                if widget.hover then selected = ID end
            end
            if selected then
                local widget = self.widgets[selected]
                widget.selected = clicked
                if key["delete"] then 
                    table.remove(sorted_widgets, self.priority[selected])
                    self:del(selected)
                else
                    self.selected[selected] = widget
                    local i = 0
                    for k,v in pairs(self.priority) do
                        if v > self.priority[selected] then self.priority[k] = v-1 end
                        i = i + 1
                    end
                    self.priority[selected] = i
                end
            end
        end

        for _,ID in ipairs(sorted_widgets) do
            local widget = self.widgets[ID]
            if not widget.hidden then
                if widget.hover then self.hover[ID] = true
                else self.hover[ID] = nil end
                widget:draw()
                self.WidgetMover(self, widget)
            end
        end
        self.lastkey = input.get()
    end,

    -- Handles widget movement
    WidgetMover = function (self, widget)
        local key, lastkey = input.get(), self.lastkey
        local x, y = key["xmouse"], key["ymouse"]
        local ID = widget.ID

        if key["control"] and key["shift"] then
            if key["leftclick"] and not lastkey["leftclick"] and ((widget.hover and widget.selected) or self.moving[ID]) then
                self.moving[ID] = {x-widget.x, y-widget.y}  -- store the *distance* from cursor to coords
            elseif key["rightclick"] and not lastkey["rightclick"] and widget.hover then
                self.moving[ID] = false
            end
            if widget.hover then  -- display coords
                local displaystring = tostring(widget.x)..","..tostring(widget.y)
                local xDisplay = math.max(2, math.min(239-4*displaystring:len(), widget.x-12))
                local yDisplay = math.max(2, math.min(152, widget.y-12))
                gui.text(xDisplay, yDisplay, displaystring)
                local i = 2
            end
        else self.moving[ID] = false end

        if self.moving[ID] then
            if key["leftclick"] then
                widget.x = x - self.moving[ID][1]
                widget.y = y - self.moving[ID][2]
            else
                if key["left"] and not lastkey["left"] then widget.x = widget.x - 1 end
                if key["right"] and not lastkey["right"] then widget.x = widget.x + 1 end
                if key["up"] and not lastkey["up"] then widget.y = widget.y - 1 end
                if key["down"] and not lastkey["down"] then widget.y = widget.y + 1 end
            end
        end
    end,

    -- Removes widgets
    del = function(self, ID)
        if type(ID) == "table" then ID = ID.ID end
        local widget = self.widgets[ID]
        if widget then
            if next(widget.embedded or {}) then 
                for k,v in pairs(widget.embedded) do v[1]:del() end 
            end
            for k,v in pairs(widget) do widget[k] = nil end
            for k,v in pairs(self.priority) do
                if v > self.priority[ID] then self.priority[k] = v - 1 end
            end
            for _,t in pairs {self.widgets, self.priority, self.hover, self.moving, self.selected} do
                t[ID] = nil
            end
        end
    end,
}



-------------------
----- WIDGETS -----
-------------------


-- An editable input box that returns its text when you press enter
function InputBox(x, y, charlimit, text, flags)

    x, y = x or 0, y or 0
    charlimit = charlimit or 28
    text = text or ""
    flags = flags or 1  -- 0x1: clear text on enter;  0x2: deselect on enter;  0x4: hide box;  0x8: single color

    local cursorpos = 1
    local lastchar, lastcharhold = "", 0
    local historypos = 1
    local temptext = ""
    local lastkey = {}

    local function draw(self)

        local key, lastkey = Widgets.key, Widgets.lastkey
        local x, y, charlimit = self.x, self.y, self.charlimit
        if charlimit < 0 then charlimit = self.text:len() + 1 end
        if bit.band(self.flags,1) ~= 0 and self.event then self.text = "" end
        self.event = false
        cursorpos = math.min(self.text:len()+1, math.max(1, cursorpos))

        -- Draws the input box
        if bit.band(self.flags,8) ~= 0 then self.colors_inactive = self.colors_active end
        local tc1, tc2, bc1, bc2 = unpack(self.colors_active)
        local tc3, tc4, bc3, bc4 = unpack(self.colors_inactive)
        local x1, y1, x2, y2 = x, y, x+4*charlimit+4, y+11
        self.hover = cursorbounds(x1, y1, x2, y2)

        -- Draws the text
        if self.active then
            if bit.band(self.flags,4) == 0 then gui.box(x1, y1, x2, y2, bc1, bc2) end
            gui.text(x1+3, y1+2, self.text, tc1, tc2)
            if cursorpos <= charlimit then gui.text(x1+4*cursorpos-1, y1+4, "_") end
        else 
            if bit.band(self.flags,4) == 0 then gui.box(x1, y1, x2, y2, bc3, bc4) end
            gui.text(x1+3, y1+2, self.text, tc3, tc4)
        end

        -- Checks these inputs regardless of writestate
        if key["leftclick"] then
            if self.hover then 
                cursorpos = math.max(1, math.min(math.floor((key["xmouse"]-x-3)/4), self.text:len())+1)
                self.active = true
            else self.active = false end
        end
        if key["enter"] and not lastkey["enter"] then 
            if self.active and self.text ~= "" then
                self.event = true
                if self.text ~= "" then
                    table.insert(self.history, self.text)
                    historypos = #self.history + 1 
                end
                if bit.band(self.flags,2) ~= 0 then self.active = false end
                if self.func then self.func(self.text) end
            end
        end
        if key["escape"] and not lastkey["escape"] then self.active = false end
        
        -- Only executes when input box is active
        if self.active then
            local shiftstate = 1
            if key["shift"] then shiftstate = 2 end
            for k in pairs(key) do
                if TotalCharList[k] then
                    if k == lastchar then lastcharhold = lastcharhold + 1 end
                    if not lastkey[k] then lastchar, lastcharhold = k, 0 end
                    if not lastkey[k] or (k==lastchar and lastcharhold > 30) then 
                        local char = ""
                        if self.charlist[k] ~= nil then
                            if type(self.charlist[k]) == "table" then char = self.charlist[k][shiftstate]
                            else char = k end
                        end
                        if char:len() == 1 and self.text:len() < charlimit then
                            if LetterList[char:upper()] and key["capslock"] then char = LetterList[char:upper()][2] end
                            self.text = self.text:sub(1,cursorpos-1) .. char .. self.text:sub(cursorpos)
                            cursorpos = cursorpos + 1
                        elseif key["backspace"] and self.text:len() > 0 then
                            if key["control"] then 
                                self.text = self.text:sub(cursorpos, -1)
                                cursorpos = 1
                            else 
                                self.text = self.text:sub(1,math.max(0, cursorpos-2)) .. self.text:sub(cursorpos)
                                cursorpos = cursorpos - 1
                            end
                        elseif key["delete"] and self.text:len() > 0 then
                            if key["control"] then 
                                self.text = self.text:sub(1, cursorpos-1)
                            else 
                                self.text = self.text:sub(1,math.max(0, cursorpos-1)) .. self.text:sub(cursorpos+1, -1)
                            end
                        elseif key["left"] then 
                            if key["control"] then cursorpos = 1
                            else cursorpos = cursorpos-1 end
                        elseif key["right"] then 
                            if key["control"] then cursorpos = charlimit + 1
                            else cursorpos = cursorpos+1 end
                        elseif key["up"] then
                            if historypos > 1 then
                                historypos = historypos - 1
                                if historypos == #self.history then temptext = self.text end
                                self.text = self.history[historypos]
                                cursorpos = charlimit + 1
                            end
                        elseif key["down"] then
                            if historypos <= #self.history then
                                historypos = historypos + 1
                                if historypos <= #self.history then self.text = self.history[historypos]
                                else self.text = temptext; temptext = "" end
                                cursorpos = charlimit + 1
                            end
                        elseif key["home"] then cursorpos = 1
                        elseif key["end"] then cursorpos = charlimit+1
                        end
                    end
                end
            end
        end
    end

    return Widgets:new {
        x=x, y=y, charlimit=charlimit, text=text, flags=flags, active=false, charlist=TotalCharList, 
        history={}, class="InputBox", event=false, func=nil, hover=false, draw=draw,
        colors_active={0xFFFFFFFF, 0x000000FF, 0xC0C0C0C0, 0x000000FF},
        colors_inactive={0xC0C0C080, 0x808080FF, 0xC0C0C080, 0x00000040},
    }
end


-- A widget alternative to gui.text
function TextBox(x, y, text, anchor, color1, color2)
    x, y = x or 0, y or 0
    text = text or "text"
    
    local function draw(self)
        local key = Widgets.key
        local x, y = self.x, self.y
        if self.anchor == 1 then 
            x = x - 2*self.text:len()
        elseif self.anchor == 2 then 
            x = x - 4*self.text:len() 
        end
        self.hover = cursorbounds(x, y, x + 4*self.text:len(), y+8)
        gui.text(x, y, self.text, self.color1, self.color2)
    end

    return Widgets:new {
        x=x, y=y, text=text, color1=color1, color2=color2, anchor=0, 
        class="TextBox", hover=false, draw=draw
    }
end


-- Makes a CheckBox that returns its state when changed
function CheckBox(x,y)
    x, y = x or 0, y or 0
    
    local function draw(self)
        local key, lastkey = Widgets.key, Widgets.lastkey
        local x, y = self.x, self.y
        self.event = false
        self.hover = cursorbounds(x, y, x+4, y+4)

        if key["leftclick"] and not lastkey["leftclick"] and self.hover then
            self.state = not self.state
            self.event = true
            if self.func then self.func(self.state) end
        end
        gui.box(x, y, x+4, y+4, self.colors[2], self.colors[3])
        if self.state then
            if self.style == "x" then
                gui.line(x, y, x+4, y+4, self.colors[1])
                gui.line(x, y+4, x+4, y, self.colors[1])
            elseif self.style == "check" then
                gui.line(x, y+2, x+2, y+4, self.colors[1])
                gui.line(x+2, y+4, x+4, y-2, self.colors[1])
                gui.line(x+2, y+4, x+4, y-1, self.colors[1])
            end
        end
    end

    return Widgets:new {
        x=x, y=y, state=false, style="check", class="CheckBox", 
        event=false, func=nil, hover=false, draw=draw,
        colors={0x40FF40FF, 0xC0C0C0FF, 0x000000FF},
    }
end


-- A button that calls func when clicked
function Button(x, y, text, func)
    x, y = x or 0, y or 0
    text = text or "click"

    local function draw(self)
        local key, lastkey = Widgets.key, Widgets.lastkey
        local tc1, tc2, bc1, bc2 = unpack(self.colors_unclicked)
        local tc3, tc4, bc3, bc4 = unpack(self.colors_clicked)
        local x1, y1, x2, y2 = self.x, self.y, self.x+4*self.text:len()+2, self.y+8
        self.event = false
        self.hover = cursorbounds(x1, y1, x2, y2)

        if self.hover and key["leftclick"] and 
            (self.state == true or not lastkey["leftclick"]) then
            gui.box(x1, y1, x2, y2, bc1, bc2)
            gui.text(x1+2, y1+1, self.text, tc1, tc2)
            if not self.state then 
                self.state = true
                self.event = true
                if self.func then self.func() end
            end
        else
            gui.box(x1, y1, x2, y2, bc3, bc4)
            gui.text(x1+2, y1+1, self.text, tc3, tc4)
            if self.state then self.event = true end
            self.state = false
        end
    end

    return Widgets:new {
        x=x, y=y, text=text, state=false, class="Button",
        event=false, func=func, hover=false, draw=draw,
        colors_unclicked = {0xFFFFFFE0, 0x000000E0, 0x606060FF, 0xB0B0B0FF},
        colors_clicked = {0xFFFFFFFF, 0x000000FF, 0xC0C0C0FF, 0xA0A0A0FF},
    }
end


-- A group of buttons where only one can be selected; returns the option name when changed
function Radio(x, y, options)
    x, y = x or 0, y or 0
    options = options or {""}

    local function draw(self)
        local key, lastkey = Widgets.key, Widgets.lastkey
        local x, y = self.x, self.y
        local tc1, tc2 = unpack(self.colors_txt)
        local bc1, bc2, bc3, bc4 = unpack(self.colors_rad)
        self.event = false

        local maxlen = 0
        for k,v in pairs(self.options) do
            local bc
            if self.index == k then bc = bc4
                gui.box(x+1, y+2, x+3, y+4, bc1, bc1)
            else bc = bc2
                gui.box(x+1, y+2, x+3, y+4, bc3, bc3)
            end
            gui.line(x+1, y+1, x+3, y+1, bc)
            gui.line(x+1, y+5, x+3, y+5, bc)
            gui.line(x, y+2, x, y+4, bc)
            gui.line(x+4, y+2, x+4, y+4, bc)
            gui.text(x+8, y, v, tc1 , tc2)
            maxlen = math.max(maxlen, v:len())
            if key["leftclick"] and not lastkey["leftclick"] and cursorbounds(x, y, x+4, y+7) then
                if k ~= self.index then 
                    self.event = true
                    self.index = k
                    self.value = v
                    if self.func then self.func(v) end
                end
            end
            y = y + 10
        end
        self.hover = cursorbounds(self.x, self.y, x+4*maxlen+8, y-2)
    end

    return Widgets:new {
        x=x, y=y, options=options, index=0, value="", 
        class="Radio", event=false, func=nil, hover=false, draw=draw,
        colors_txt = {0xFFFFFFFF, 0x000000FF}, 
        colors_rad = {0x404040FF, 0x000000FF, 0xC0C0C0FF, 0x303030FF},
    }
end


-- An adjustable slider; Orientation may be 'v' or 'h' for vertical/horizontal
function Slider(x, y, left, right, step, orientation, length)
    x, y = x or 2, y or 5
    left, right = left or 0, right or 10
    step = step or 1
    orientation = orientation or "h"
    length = length or 50
    local sliderPos = x

    local function draw(self)
        local key = Widgets.key
        local x, y, left, right, step, length, ori = 
            self.x, self.y, self.left, self.right, self.step, self.length, self.orientation
        local linec, bc1, bc2 = self.color_line, unpack(self.color_slide)
        if not key["leftclick"] then self.drag = false end
        self.event = false

        if ori == "h" then 
            gui.line(x, y, x+length, y, linec)
            self.hover = cursorbounds(x-2, y-4, x+length+2, y+4)
        elseif ori == "v" then 
            gui.line(x, y, x, y+length, linec)
            self.hover = cursorbounds(x-4, y-2, x+4, y+length+2)
        end

        if self.drag then
            local initvalue = self.value
            -- round value to nearest multiple of step based on cursor
            if ori == "h" then
                self.value = step*math.floor((key["xmouse"]-sliderPos) / length * (right-left) / step + 0.5) + self.value
            elseif ori == "v" then 
                self.value = step*math.floor((key["ymouse"]-sliderPos) / length * (right-left) / step + 0.5) + self.value
            end
            
            if self.value ~= initvalue then 
                self.event = true
                if self.func then self.func(self.value) end
            end
        end

        min, max = math.min(left, right), math.max(left, right)
        if self.value < min then self.value = min
        elseif self.value > max then self.value = max
        end

        if ori == "h" then
            if right == left then sliderPos = x + length/2
            else sliderPos = (self.value-left) / (right-left) * length + x end
            gui.box(sliderPos-2, y-4, sliderPos+2, y+4, bc1, bc2)
            if key["leftclick"] and cursorbounds(sliderPos-2, y-4, sliderPos+2, y+4) then
                self.drag = true
            end
        elseif ori == "v" then 
            if right == left then sliderPos = y + length/2
            else sliderPos = (self.value-left) / (right-left) * length + y end
            gui.box(x-4, sliderPos-2, x+4, sliderPos+2, bc1, bc2)
            if key["leftclick"] and cursorbounds(x-4, sliderPos-2, x+4, sliderPos+2) then
                self.drag = true
            end
        end
    end

    return Widgets:new {
        x=x, y=y, left=left, right=right, step=step, orientation=orientation, 
        length=length, value=0, drag=false, class="Slider", 
        event=false, func=nil, hover=false, draw=draw,
        color_line = 0x000000FF, color_slide = {0xC0C0C0FF, 0x000000FF},
    }
end


-- A window for displaying text data; data may be a string or a table, or a function that returns a string/table
function Window(x, y, data, charwidth, charheight)

    x, y = x or 0, y or 0
    data = data or ""
    charwidth = charwidth or 20
    charheight = charheight or 10
    local clickstate, clickhold = false, 0
    local maxh_index, maxv_index
    local linePositions
    local datastring


    local function newtext(newdata)  -- parses data and updates maxv_index, maxh_index, linePositions, and datastring
        newdata = newdata or ""
        if type(newdata) == "function" then newdata = newdata() end
        if type(newdata) == "table" then newdata = table_string(newdata, 1) 
        elseif type(newdata) == "number" then newdata = tostring(newdata) end
        if datastring ~= newdata then
            linePositions = {1}
            local maxlen = 0
            for line in newdata:gmatch("[^\r\n]*\n?") do
                table.insert(linePositions, (linePositions[#linePositions] or 0) + line:len())
                maxlen = math.max(maxlen, line:len())
            end
            maxv_index = #linePositions - charheight + 1
            maxh_index = maxlen - charwidth + 2
            datastring = newdata
        end
    end

    newtext(data)

    local function draw(self)
        local key, lastkey = Widgets.key, Widgets.lastkey
        if not key["leftclick"] then
            clickstate, clickhold = false, 0
            self.drag_h = false
            self.drag_v = false 
        elseif clickstate then
            clickhold = clickhold + 1
        end
        if (data ~= self.data) or self.auto_update then data = self.data;  newtext(self.data) end
        local x1, y1, x2, y2 = self.x, self.y, self.x+4*self.charwidth+4, self.y+9*self.charheight+2
        local charwidth, charheight = self.charwidth, self.charheight
        local text_c1, text_c2 = unpack(self.colors_txt)
        local window_c1, window_c2 = unpack(self.colors_window)
        local scroll_c1, scroll_c2, scroll_c3 = unpack(self.colors_scroll)
        
        -- Draws the Window
        gui.box(x1, y1, x2, y2, window_c1, window_c2)  -- text box
        
        if maxv_index > 1 then
            gui.box(x2, y1, x2+6, y2, scroll_c2, scroll_c3)  -- outer vertical scroll box
            gui.line(x2, y1+5, x2+6, y1+5, scroll_c3)
            gui.line(x2, y2-5, x2+6, y2-5, scroll_c3)
            gui.line(x2+2, y1+3, x2+4, y1+3, scroll_c3); gui.pixel(x2+3, y1+2, scroll_c3)
            gui.line(x2+2, y2-3, x2+4, y2-3, scroll_c3); gui.pixel(x2+3, y2-2, scroll_c3)
        end

        if maxh_index > 1 then
            gui.box(x1, y2, x2, y2+6, scroll_c2, scroll_c3)  -- outer horizontal scroll box
            gui.line(x1+5, y2, x1+5, y2+6, scroll_c3)
            gui.line(x2-5, y2, x2-5, y2+6, scroll_c3)
            gui.line(x1+3, y2+2, x1+3, y2+4, scroll_c3); gui.pixel(x1+2, y2+3, scroll_c3)
            gui.line(x2-3, y2+2, x2-3, y2+4, scroll_c3); gui.pixel(x2-2, y2+3, scroll_c3)
        end
        
        -- Displays the text
        local x, y = self.x+3, self.y+2
        for i=self.index, math.min(#linePositions-1, self.index+charheight-1) do
            line = datastring:sub(linePositions[i], (linePositions[i+1] or 0) - 1)
            line = line:sub(self.index_h):sub(1,charwidth)
            if i == self.highlight then gui.box(x1+2, y-1, x2-2, y+7, 0x8080FFFF) end
            gui.text(x, y, line, text_c1, text_c2)
            y = y + 9
        end
        
        -- Index Calculation
        local x1_v, y1_v = x2+3, y1+10  -- edge of vertical scroll region
        local x1_h, y1_h = x1+10, y2+3  -- edge of horizontal scroll region
        if self.drag_v == true then
            self.index = math.floor((key["ymouse"]-y1_v) / (y2-y1-20) * (maxv_index-1) + 0.5) + 1
        end
        if self.drag_h == true then
            self.index_h = math.floor((key["xmouse"]-x1_h) / (x2-x1-20) * (maxh_index-1) + 0.5) + 1
        end

        -- Boundary Check
        self.index = math.max(1, math.min(maxv_index, self.index))
        self.index_h = math.max(1, math.min(maxh_index, self.index_h))

        -- Position Calculation
        local scroll_v = (self.index-1) / (maxv_index-1) * (y2-y1-20)  -- position of vertical scrollbar relative to lowest point
        local scroll_h = (self.index_h-1) / (maxh_index-1) * (x2-x1-20)  -- position of horizontal scrollbar relative to lowest point
        if maxv_index > 1 then gui.box(x1_v-1, y1_v+scroll_v-3, x1_v+1, y1_v+scroll_v+3, scroll_c1, scroll_c1) end
        if maxh_index > 1 then gui.box(x1_h+scroll_h-3, y1_h-1, x1_h+scroll_h+3, y1_h+1, scroll_c1, scroll_c1) end

        -- Click Checks
        if key["leftclick"] then
            if cursorbounds(x1_v-2, y1_v+scroll_v-3, x1_v+2, y1_v+scroll_v+3) then  -- vertical scroll handle
                self.drag_v = true
            elseif cursorbounds(x1_h+scroll_h-3, y1_h-2, x1_h+scroll_h+3, y1_h+2) then  -- horizontal scroll handle
                self.drag_h = true
            elseif (not lastkey["leftclick"] or clickhold > 30) and not(self.drag_v or self.drag_h) then
                if cursorbounds(x1, y1, x2, y2) then
                    self.highlight = math.max(1, math.min(#linePositions-1, self.index + math.floor((key["ymouse"] - (self.y+1))/9)))
                elseif not self.hover then
                    self.highlight = nil
                end
                local direction = 1
                if cursorbounds(x2, y1, x2+6, y2) then  -- hovering over vertical scroll bar
                    clickstate = true
                    local y = key["ymouse"]
                    if y < y1_v+scroll_v then direction = -1 end
                    if y >= y1+5 and y <= y2-5 then
                        local maxchange = math.floor(math.abs(y1_v+scroll_v-y) / (y2-y1-20) * (maxv_index-1) + 0.5)
                        self.index = self.index + direction*math.min(charheight, maxchange)
                    else
                        self.index = self.index + direction
                    end
                    self.index = math.max(1, math.min(maxv_index, self.index)) 
                elseif cursorbounds(x1, y2, x2, y2+6) then  -- hovering over horizontal scroll bar
                    clickstate = true
                    local x = key["xmouse"]
                    if x < x1_h+scroll_h then direction = -1 end
                    if x >= x1+5 and x <= x2-5 then 
                        local maxchange = math.floor(math.abs(x1_h+scroll_h-x) / (x2-x1-20) * (maxh_index-1) + 0.5)
                        self.index_h = self.index_h + direction*math.min(5, maxchange)
                    else
                        self.index_h = self.index_h + direction
                    end
                    self.index_h = math.max(1, math.min(maxh_index, self.index_h))
                end
            end
        end

        if self.highlight then
            self.line = datastring:sub(linePositions[self.highlight] or 1, (linePositions[self.highlight+1] or 0)-1):match("%s*([^\n]*)")
        end
        self.hover = cursorbounds(x1, y1, x2+6, y2+6)
        if key["escape"] and self.hover then self.highlight = nil end

        -- Update position and draw embedded widgets
        for k,v in pairs(self.embedded) do
            local widget, relx, rely = unpack(v)
            if widget.ID then
                widget.x = relx + self.x
                widget.y = rely + self.y
                widget:draw()
                if widget.hover then self.hover = true end
            else
                table.remove(self.embedded, k)
            end
        end
    end

    -- Find first instance of string in data, starting from current position
    local function search(self, string, start)
        start = start or linePositions[self.highlight or 1]
        local pos = datastring:sub(start):find(string)
        if not pos then pos = datastring:sub(1, start):find(string)
        else pos = pos + start - 1 end
        if pos then 
            self.highlight = binsearch(linePositions, pos)
            if self.highlight < 1 then self.highlight = 1 end
            self.index = math.min(maxv_index, self.highlight)
        end
    end

    -- Embed a widget, causing it to move with the window, and display in front of it
    local function embed(self, widget)
        table.insert(self.embedded, {widget, widget.x-self.x, widget.y-self.y})
        widget.hidden = true
    end

    -- Detach an embedded widget
    local function detach(self, widget)
        for k,v in pairs(self.embedded) do
            if v[1] == widget then self.embedded[k] = nil end
        end
        widget.hidden = false
    end

    return Widgets:new {
        x=x, y=y, data=data, charwidth=charwidth, charheight=charheight, auto_update=true,
        index=1, index_h=1, highlight=nil, line="", embedded={}, embed=embed, detach=detach, 
        drag_v=false, drag_h=false, class="Window", event=false, func=nil, hover=false, draw=draw, search=search,
        colors_window = {0xC0C0C0C0, 0x00000FF}, 
        colors_scroll = {0x808080FF, 0xE0E0E0FF, 0x00000FF},
        colors_txt = {0xFFFFFFFF, 0x000000FF},
    }
end


-- A Canvas for drawing lines and shapes
function Canvas(x, y, width, height)
    
    x, y = x or 0, y or 16
    width, height = width or 100, height or 100
    last_width, last_height = width, height
    local background = 0xFFFFFFFF
    local palette={
        0x000000FF, 0xFFFFFFFF, 0x00000000, 0x808080FF, 
        0xC3C3C3FF, 0xB97A57FF, 0x880015FF, 0xED1C24FF, 
        0xFFAEC9FF, 0xFF7F27FF, 0xFFC90EFF, 0xFFF200FF, 
        0x22B14CFF, 0xB5E61DFF, 0x00A2E8FF, 0x99D9EAFF, 
        0x3F48CCFF, 0x7092BEFF, 0xA349A4FF, 0xC8BFE7FF, 
    }

    local bitmap = {}
    for x=1, width do
        bitmap[x] = {}
        for y=1, height do bitmap[x][y] = background end
    end
    local bitmap_history = {}
    local lastkey
    local prevx, prevy
    local modes = {"pencil", "brush", "line", "box", "circle", "triangle", "fill", "dropper", "undo", "clear"}
    local mode_drawings = {  -- Draws the button icons
        function(x,y) gui.pixel(x+4, y+4, 0x000000FF) end,  --pencil
        function(x,y)  --brush
            gui.line(x+3, y+4, x+5, y+4, 0x000000FF)
            gui.line(x+4, y+3, x+4, y+5, 0x000000FF)
        end,
        function(x,y) gui.line(x+2, y+6, x+6, y+2, 0x000000FF) end,  --line
        function(x,y) gui.box(x+2, y+2, x+6, y+6, 0, 0x000000FF) end,  --box
        function(x,y)  --circle
            gui.line(x+2, y+3, x+2, y+5, 0x000000FF)
            gui.line(x+3, y+6, x+5, y+6, 0x000000FF)
            gui.line(x+6, y+5, x+6, y+3, 0x000000FF)
            gui.line(x+5, y+2, x+3, y+2, 0x000000FF)
        end,
        function(x,y)  --triangle
            gui.line(x+2, y+6, x+4, y+1, 0x000000FF)
            gui.line(x+4, y+1, x+6, y+6, 0x000000FF)
            gui.line(x+2, y+6, x+6, y+6, 0x000000FF)
        end,
        function(x,y)  --fill
            gui.box(x+2, y+3, x+6, y+6, 0x000000FF)
            gui.pixel(x+2, y+2, 0x000000FF)
            gui.pixel(x+6, y+2, 0x000000FF)
        end,
        function(x,y)  --dropper
            gui.line(x+2, y+5, x+5, y+2, 0x000000FF)
            gui.line(x+3, y+6, x+6, y+3, 0x000000FF)
            gui.line(x+4, y+2, x+6, y+4, 0x000000FF)
            gui.pixel(x+2, y+6, 0x000000FF); gui.pixel(x+6, y+2, 0x000000FF); 
        end,
        function(x,y)  --undo
            gui.line(x+2, y+6, x+6, y+6, 0x000000FF)
            gui.line(x+6, y+6, x+6, y+2, 0x000000FF)
            gui.line(x+6, y+2, x+2, y+2, 0x000000FF)
            gui.line(x+3, y+1, x+3, y+3, 0x000000FF)
        end,
        function(x,y)  --clear
            gui.line(x+2, y+2, x+2, y+6, 0x000000FF)
            gui.line(x+2, y+6, x+6, y+6, 0x000000FF)
            gui.line(x+6, y+6, x+6, y+2, 0x000000FF)
        end,
    }
    local mode_click = false -- used to make the button look nice when clicked
    local temp_modes = {undo=true, clear=true} -- modes that don't persist
    local last_mode = nil  -- for returning to after using the dropper

    local shape_drawings = {  -- Draws shapes
        line = function(self, x1, y1, x2, y2, color, temp) 
            self:line(x1, y1, x2, y2, color, temp) 
        end,
        box = function(self, x1, y1, x2, y2, color, temp) 
            self:line(x1, y1, x2, y1, color, temp)
            self:line(x2, y1, x2, y2, color, temp)
            self:line(x2, y2, x1, y2, color, temp)
            self:line(x1, y2, x1, y1, color, temp)
        end,
        circle = function(self, x1, y1, x2, y2, color, temp)
            local radius = math.sqrt((x2-x1)^2 + (y2-y1)^2)
            local pixelcount = math.max(math.floor(radius*10))
            local ratio = 2*math.pi/pixelcount
            for angle=1,pixelcount do
                local x,y = radius*math.cos(angle*ratio)+x2, radius*math.sin(angle*ratio)+y2
                self:pixel(math.floor(x+0.5), math.floor(y+0.5), color, temp)
            end
        end,
        triangle = function(self, x1, y1, x2, y2, color, temp)
            local side_length = math.sqrt(4/3*((x2-x1)^2 + (y2-y1)^2))
            local ratio = math.pi/180
            local mid_angle = math.atan2(y1-y2,x1-x2)/ratio
            local tx1, ty1 = x2, y2
            local tx2, ty2 = tx1 + side_length*math.cos((mid_angle-30)*ratio), ty1 + side_length*math.sin((mid_angle-30)*ratio)
            local tx3, ty3 = tx1 + side_length*math.cos((mid_angle+30)*ratio), ty1 + side_length*math.sin((mid_angle+30)*ratio)
            self:line(tx1, ty1, tx2, ty2, color, temp)
            self:line(tx1, ty1, tx3, ty3, color, temp)
            self:line(tx2, ty2, tx3, ty3, color, temp)
        end,
    }
    local temp_shape  -- determines whether a temporary shape is drawn on the canvas
    local last_bound_state = false  -- whether the cursor was in the boundaries last frame
    local last_edit = false  -- whether an edit was made last frame
    local compress_next = false  -- whether the last history item needs to be compressed


    local function draw(self)
        local key, lastkey = Widgets.key, Widgets.lastkey
        if last_width ~= self.width or last_height ~= self.height then
            self:add_copy()
            self:resize()
            self:compress_copy()
        end

        local x1, y1, x2, y2 = self.x-1, self.y-1, self.x+self.width, self.y+self.height  -- box around editable region
        background = self.background
        palette = self.palette
        local color = self.color
        local mode = self.mode
        local modeX, modeY = x1+1, y1-18  -- Mode options coordinates
        local palX, palY = x1, y1-8  -- Palette options coordinates

        -- Draws the interface
        if self.show then
            gui.box(x1, y1, x2, y2, 0x00000000, 0x000000FF)

            -- Mode options
            local offset = 0
            for i=1,#modes do
                gui.box(modeX+offset, modeY, modeX+offset+8, modeY+8, 0xFFFFFFFF, 0x000000FF)
                mode_drawings[i](modeX+offset, modeY)
                offset = offset + 10
            end
            if key["leftclick"] and cursorbounds(modeX, modeY, modeX+10*#modes-2, modeY+8) then
                local mode_index = math.floor((key["xmouse"] - modeX)/10)+1
                if not lastkey["leftclick"] then
                    mode_click = mode_index
                    mode = modes[mode_index]
                    if mode == "dropper" then last_mode = self.mode
                    elseif mode == "undo" then self:undo()
                    elseif mode == "clear" then self:add_copy(); self:clear(); self:compress_copy() end
                    if not temp_modes[mode] then self.mode = mode end  -- mode will update mode next frame
                end
                if mode_click == mode_index then 
                    gui.box(modeX+mode_index*10-10, modeY, modeX+8+mode_index*10-10, modeY+8, "#00000040")
                else mode_click = false 
                end
            end
            for k,v in pairs(modes) do 
                if v == self.mode then gui.box(modeX+10*k-10, modeY, modeX+10*k-2, modeY+8, 0, 0x808080FF) end 
            end

            -- Palette
            for i=1,#palette do
                gui.box(palX+5*i-4, palY+1, palX+5*i, palY+5, palette[i], palette[i])
            end
            if key["leftclick"] and not lastkey["leftclick"] and cursorbounds(palX+1, palY, palX+5*#palette, palY+6) then
                self.color = palette[math.floor((key["xmouse"] - (palX+1))/5) + 1]
            end
            for k,v in pairs(palette) do
                if v == self.color then gui.box(palX+5*k-5, palY, palX+5*k+1, palY+6, 0, 0xA0A0A0FF) end
            end
        end

        -- Draws the bitmap to the screen
        for x,column in pairs(bitmap) do
            for y,color in pairs(column) do
                gui.pixel(x+x1, y+y1, color)
            end
        end

        -- Drawing Area Logic
        if cursorbounds(x1+1, y1+1, x2-1, y2-1) or last_bound_state or temp_shape then
            gui.pixel(key["xmouse"], key["ymouse"], color)
            if mode == "brush" then 
                gui.line(key["xmouse"]-1, key["ymouse"], key["xmouse"]+1, key["ymouse"], color)
                gui.line(key["xmouse"], key["ymouse"]-1, key["xmouse"], key["ymouse"]+1, color)
            end
            local relx = key["xmouse"]-x1
            local rely = key["ymouse"]-y1
            if prevx == nil or prevy == nil then prevx, prevy = relx, rely end
            if shape_drawings[temp_shape] then
                shape_drawings[temp_shape](self, prevx, prevy, relx, rely, color, true)
            end
            if key["leftclick"] then
                if not lastkey["leftclick"] then 
                    prevx, prevy = relx, rely
                end
                if mode == "pencil" then
                    if not last_edit then self:add_copy() end
                    self:line(prevx, prevy, relx, rely, color)
                    prevx, prevy = relx, rely
                    last_edit = true
                elseif mode == "brush" then
                    if not last_edit then self:add_copy() end
                    self:line(prevx, prevy, relx, rely, color)
                    self:line(prevx-1, prevy, relx-1, rely, color)
                    self:line(prevx+1, prevy, relx+1, rely, color)
                    self:line(prevx, prevy-1, relx, rely-1, color)
                    self:line(prevx, prevy+1, relx, rely+1, color)
                    prevx, prevy = relx, rely
                    last_edit = true
                elseif mode == "fill" then
                    if not lastkey["leftclick"] then 
                        self:add_copy()
                        self:fill(relx, rely, color)
                        self:compress_copy()
                    end
                elseif mode == "dropper" then
                    if not lastkey["leftclick"] then 
                        self.color = bitmap[relx][rely]
                        self.mode = last_mode
                    end
                else temp_shape = mode
                end
            elseif shape_drawings[temp_shape] then
                self:add_copy()
                shape_drawings[temp_shape](self, prevx, prevy, relx, rely, color)
                temp_shape = nil
                self:compress_copy()
            end
        end

        last_bound_state = cursorbounds(x1+1, y1+1, x2-1, y2-1)  -- check previous frame
        self.hover = cursorbounds(x1, y1, x2, y2)
            or cursorbounds(modeX, modeY, modeX+10*#modes-2, modeY+10)
            or cursorbounds(palX, palY, palX+5*#palette+1, palY+6)
        if not key["leftclick"] then 
            temp_shape, prevx, prevyl, last_edit = nil, nil, nil, nil
            if compress_next then self:compress_copy() end
        elseif mode == "pencil" or mode == "brush" then  -- track cursor when out of bounds for better entry
            prevx, prevy = key["xmouse"]-x1, key["ymouse"]-y1
        end
    end


    local function pixel(self, x, y, color, temp)
        if x >= 1 and x <= self.width and y >= 1 and y <= self.width then
            if temp then gui.pixel(x+self.x-1, y+self.y-1, color)
            else self.bitmap[x][y] = color end
        end
    end


    local function line(self, x1, y1, x2, y2, color, temp)
        local bitmap = self.bitmap

        x1, y1, x2, y2 = math.floor(0.5+x1), math.floor(0.5+y1), math.floor(0.5+x2), math.floor(0.5+y2)
        if x1 == x2 and y1 == y2 then 
            self:pixel(x1, y1, color, temp) 
        end
        if x1 ~= x2 then
            local slope = (y2-y1)/(x2-x1)
            for i=math.min(x1, x2), math.max(x1, x2) do 
                self:pixel(i, y1+math.floor((i-x1)*slope+0.5), color, temp)
            end
        end
        if y1 ~= y2 then
            local slope = (x2-x1)/(y2-y1)
            for i=math.min(y1, y2), math.max(y1, y2) do
                self:pixel(x1+math.floor((i-y1)*slope+0.5), i, color, temp)
            end
        end
    end


    local function fill(self, x, y, color)
        local bitmap = self.bitmap
        local init_color = bitmap[x][y]
        if color == init_color then return end
        local width, height = self.width, self.height
        bitmap[x][y] = color
        local currentlayer = {{x, y}}
        local checked = {}
        for i=1,width do table.insert(checked, {}) end
        
        local function check(x, y, nextlayer)
            if not checked[x][y] then
                checked[x][y] = true
                if bitmap[x][y] == init_color then 
                    bitmap[x][y] = color
                    table.insert(nextlayer, {x, y})
                end
            end
        end

        while next(currentlayer) do
            nextlayer = {}
            for _, coords in pairs(currentlayer) do
                local x, y = unpack(coords)
                if x < width then check(x+1, y, nextlayer) end
                if y > 1 then check(x, y-1, nextlayer) end
                if x > 1 then check(x-1, y, nextlayer) end
                if y < height then check(x, y+1, nextlayer) end
            end
            currentlayer = nextlayer
        end
    end


    local function add_copy(self)
        local newcopy = {}
        for x=1, last_width do newcopy[x] = {} end
        for x,column in pairs(self.bitmap) do -- make a copy of the bitmap
            for y,color in pairs(column) do newcopy[x][y] = color end
        end
        table.insert(bitmap_history, {newcopy, last_width, last_height})
        compress_next = true
    end


    -- Utilizes color list, difference comparison, and run-length-encoding
    local function compress_copy(self)
        local mismatch = false
        local bitmap = self.bitmap
        local copy, width, height = unpack(bitmap_history[#bitmap_history] or {})
        if width ~= self.width or height ~= self.height then mismatch = true end

        local lastcolor =false
        local bytes = {}
        local lengths = {}
        local byte_str = ""
        local len_str = ""
        local palette, ptranspose = {[255]="unchanged"}, {["unchanged"]=255}
        for x=1, width do
            local column = bitmap[x] or {}
            for y=1, height do
                local color = copy[x][y]
                if color ~= column[y] then 
                    mismatch = true
                    if not ptranspose[color] then 
                        table.insert(palette, color)
                        ptranspose[color] = #palette
                    end
                    color = ptranspose[color]
                else color = 255 end
                if color ~= lastcolor or #lengths == 0 then 
                    table.insert(bytes, color)
                    table.insert(lengths, 0)
                    lastcolor = color
                else 
                    lengths[#lengths] = lengths[#lengths] + 1 
                    if lengths[#lengths] == 255 then lastcolor = false end
                end
                if #bytes >= 4096 then 
                    byte_str = byte_str..string.char(unpack(bytes)); bytes = {} 
                    len_str = len_str..string.char(unpack(lengths)); lengths = {}
                end
            end
        end
        byte_str = byte_str..string.char(unpack(bytes))
        len_str = len_str..string.char(unpack(lengths))
        table.remove(bitmap_history)
        table.insert(bitmap_history, {byte_str, len_str, palette, width, height})
        if mismatch == true then
            if #bitmap_history > 10 then table.remove(bitmap_history, 1) end
        else
            table.remove(bitmap_history, #bitmap_history)
        end
        compress_next = false
    end


    local function undo(self)
        local bitmap = self.bitmap
        local copy = table.remove(bitmap_history)
        if copy then
            local bytes, lengths, palette, width, height = unpack(copy)
            if width ~= self.width or height ~= self.height then 
                self.width, self.height = width, height
                self:resize(width, height)
            end
            local x,y = 1,1
            for pos=1, bytes:len() do
                local color, length = palette[bytes:byte(pos)], lengths:byte(pos) + 1
                for i=1,length do
                    if color ~= "unchanged" then bitmap[x][y] = color end
                    if y == height then y = 1; x = x + 1
                    else y = y + 1 end
                end
            end
        end
    end


    -- Resizes canvas based on self.width and self.height, clears unused regions and fills new regions
    local function resize(self)
        local bitmap = self.bitmap
        for x=1, math.max(last_width, self.width) do
            if x <= self.width then 
                bitmap[x] = bitmap[x] or {}
                for y=1, math.max(last_height, self.height) do
                    if y <= self.height then bitmap[x][y] = bitmap[x][y] or background
                    else bitmap[x][y] = nil end
                end
            else 
                bitmap[x] = nil
            end
        end
        last_width, last_height = self.width, self.height
    end


    local function clear(self)
        for x=1, #self.bitmap do bitmap[x] = nil end
        for x=1, self.width do
            self.bitmap[x] = {}
            for y=1, self.height do
                table.insert(self.bitmap[x], background)
            end
        end
    end


    -- Exports to a .bmp file
    local function export(self, filepath)
        if not filepath:find("%.%w+$") then filepath = filepath .. ".bmp" end
        local file = io.open(filepath, "wb")
        local width, height = self.width, self.height
        local padding = width % 4
        local payload_size = (width*3+padding)*height
        local file_size = payload_size + 0x36
        local data = {}
        for i=1, 0x36 do data[i] = 0 end
        local magic_bytes = {[0x1]=0x42, [0x2]=0x4D, [0xB]=0x36, [0xF]=0x28, [0x1B]=0x1, [0x1D]=0x18}
        for k,v in pairs(magic_bytes) do data[k] = v end
        local bitmap = self.bitmap

        local function store_bytes(number, pos)
            while number > 0 do
                data[pos] = number % 256
                number = bit.rshift(number, 8)
                pos = pos + 1
            end
        end

        store_bytes(file_size, 3)
        store_bytes(width, 0x13)
        store_bytes(height, 0x17)
        store_bytes(payload_size, 0x23)
        file:write(string.char(unpack(data)))
        
        for y=height, 1, -1 do
            local data = {}
            for x=1, width do
                local color = bitmap[x][y] or 0xFFFFFFFF
                color = bit.rshift(color, 8)
                for i=1,3 do
                    data[3*(x-1)+i] = color % 256
                    color = bit.rshift(color, 8)
                end
            end
            for i=1,padding do table.insert(data, 0) end
            file:write(string.char(unpack(data)))
        end
        file:close()
    end


    -- Imports from a .bmp file
    local function import(self, filepath)
        self:add_copy()
        if not filepath:find("%.%w+$") then filepath = filepath .. ".bmp" end
        local file = io.open(filepath, "rb")
        if not file then print("Error: Could not load file"); return end
        local header = file:read(0x36)
        local bitmap = self.bitmap
        
        local function to_int(substring)
            local out = 0
            local bytearray = {substring:byte(1, substring:len())}
            for i=#bytearray,1,-1 do
                out = bit.lshift(out, 8)
                out = out + bytearray[i]
            end
            return out
        end

        if to_int(header:sub(1, 2)) ~= 0x4D42 then 
            print("Error: Imported file is not a .bmp image")
            file:close()
            return 
        end
        local width = to_int(header:sub(0x13, 0x16))
        local height = to_int(header:sub(0x17, 0x1B))
        local padding = width % 4
        self.width = width
        self.height = height
        self:resize()
        
        for y=height, 1, -1 do
            for x=1, width do
                bitmap[x][y] = bit.lshift(to_int(file:read(3)), 8) + 0xFF
            end
            file:seek("cur", padding)
        end
        file:close()
        self:compress_copy()
    end


    return Widgets:new {
        x=x, y=y, width=width, height=height, bitmap=bitmap, mode="pencil", background=background,
        palette=palette, color=palette[1], show=true, pixel=pixel, line=line, fill=fill, 
        add_copy=add_copy, compress_copy=compress_copy, undo=undo, resize=resize, clear=clear, 
        class="Canvas", hover=false, draw=draw, export=export, import=import,
    }
end