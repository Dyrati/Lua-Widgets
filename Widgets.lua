-- Character list entry format: character: {pressed,  shift+pressed}

TotalCharList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
    ['F1'] = {'F1','F1'},
    ['F2'] = {'F2','F2'},
    ['F3'] = {'F3','F3'},
    ['F4'] = {'F4','F4'},
    ['F5'] = {'F5','F5'},
    ['F6'] = {'F6','F6'},
    ['F7'] = {'F7','F7'},
    ['F8'] = {'F8','F8'},
    ['F9'] = {'F9','F9'},
    ['F10'] = {'F10','F10'},
    ['F11'] = {'F11','F11'},
    ['F12'] = {'F12','F12'},
    ['G'] = {'g','G'},
    ['H'] = {'h','H'},
    ['I'] = {'i','I'},
    ['J'] = {'j','J'},
    ['K'] = {'k','K'},
    ['L'] = {'l','L'},
    ['M'] = {'m','M'},
    ['N'] = {'n','N'},
    ['O'] = {'o','O'},
    ['P'] = {'p','P'},
    ['Q'] = {'q','Q'},
    ['R'] = {'r','R'},
    ['S'] = {'s','S'},
    ['T'] = {'t','T'},
    ['U'] = {'u','U'},
    ['V'] = {'v','V'},
    ['W'] = {'w','W'},
    ['X'] = {'x','X'},
    ['Y'] = {'y','Y'},
    ['Z'] = {'z','Z'},
    ['alt'] = {'alt','alt'},
    ['backslash'] = {'\\','|'},
    ['backspace'] = {'backspace','backspace'},
    ['capslock'] = {'capslock','capslock'},
    ['comma'] = {',','<'},
    ['control'] = {'control','control'},
    ['delete'] = {'delete','delete'},
    ['down'] = {'down','down'},
    ['end'] = {'end','end'},
    ['enter'] = {'enter','enter'},
    ['escape'] = {'escape','escape'},
    ['home'] = {'home','home'},
    ['left'] = {'left','left'},
    ['leftbracket'] = {'[','{'},
    ['leftclick'] = {'leftclick','leftclick'},
    ['minus'] = {'-','_'},
    ['numpad*'] = {'*','*'},
    ['numpad+'] = {'+','+'},
    ['numpad-'] = {'-','-'},
    ['numpad.'] = {'.','.'},
    ['numpad/'] = {'/','/'},
    ['numpad0'] = {'0','0'},
    ['numpad1'] = {'1','1'},
    ['numpad2'] = {'2','2'},
    ['numpad3'] = {'3','3'},
    ['numpad4'] = {'4','4'},
    ['numpad5'] = {'5','5'},
    ['numpad6'] = {'6','6'},
    ['numpad7'] = {'7','7'},
    ['numpad8'] = {'8','8'},
    ['numpad9'] = {'9','9'},
    ['period'] = {'.','>'},
    ['plus'] = {'=','+'},
    ['quote'] = {"'",'"'},
    ['right'] = {'right','right'},
    ['rightbracket'] = {']','}'},
    ['rightclick'] = {'rightclick','rightclick'},
    ['semicolon'] = {';',':'},
    ['shift'] = {'shift','shift'},
    ['slash'] = {'/','?'},
    ['space'] = {' ',' '},
    ['tab'] = {'    ','	'},
    ['tilde'] = {'`','~'},
    ['up'] = {'up','up'},
}

LetterList = {
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
    ['G'] = {'g','G'},
    ['H'] = {'h','H'},
    ['I'] = {'i','I'},
    ['J'] = {'j','J'},
    ['K'] = {'k','K'},
    ['L'] = {'l','L'},
    ['M'] = {'m','M'},
    ['N'] = {'n','N'},
    ['O'] = {'o','O'},
    ['P'] = {'p','P'},
    ['Q'] = {'q','Q'},
    ['R'] = {'r','R'},
    ['S'] = {'s','S'},
    ['T'] = {'t','T'},
    ['U'] = {'u','U'},
    ['V'] = {'v','V'},
    ['W'] = {'w','W'},
    ['X'] = {'x','X'},
    ['Y'] = {'y','Y'},
    ['Z'] = {'z','Z'},
}


NumberList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
}


HexNumberList = {
    ['0'] = {'0',')'},
    ['1'] = {'1','!'},
    ['2'] = {'2','@'},
    ['3'] = {'3','#'},
    ['4'] = {'4','$'},
    ['5'] = {'5','%'},
    ['6'] = {'6','^'},
    ['7'] = {'7','&'},
    ['8'] = {'8','*'},
    ['9'] = {'9','('},
    ['A'] = {'a','A'},
    ['B'] = {'b','B'},
    ['C'] = {'c','C'},
    ['D'] = {'d','D'},
    ['E'] = {'e','E'},
    ['F'] = {'f','F'},
}


DirectionList = {
    ['up'] = {'up','up'},
    ['down'] = {'down','down'},
    ['left'] = {'left','left'},
    ['right'] = {'right','right'},
}


NumpadList = {
    ['numpad*'] = {'*','*'},
    ['numpad+'] = {'+','+'},
    ['numpad-'] = {'-','-'},
    ['numpad.'] = {'.','.'},
    ['numpad/'] = {'/','/'},
    ['numpad0'] = {'0','0'},
    ['numpad1'] = {'1','1'},
    ['numpad2'] = {'2','2'},
    ['numpad3'] = {'3','3'},
    ['numpad4'] = {'4','4'},
    ['numpad5'] = {'5','5'},
    ['numpad6'] = {'6','6'},
    ['numpad7'] = {'7','7'},
    ['numpad8'] = {'8','8'},
    ['numpad9'] = {'9','9'},
}


FunctionKeyList = {
    ['F1'] = {'F1','F1'},
    ['F2'] = {'F2','F2'},
    ['F3'] = {'F3','F3'},
    ['F4'] = {'F4','F4'},
    ['F5'] = {'F5','F5'},
    ['F6'] = {'F6','F6'},
    ['F7'] = {'F7','F7'},
    ['F8'] = {'F8','F8'},
    ['F9'] = {'F9','F9'},
    ['F10'] = {'F10','F10'},
    ['F11'] = {'F11','F11'},
    ['F12'] = {'F12','F12'},
}


-- Metamethods for charlists:

local function meta_copy(a,b)  -- makes a copy of a, also copying its metatable
    local copy = b or {}
    for k,v in pairs(a) do copy[k] = v end
    setmetatable(copy, getmetatable(a))
    return copy
end 

local function add_meta(a,b)  -- returns the union of a and b
    local copy = {}
    if type(b) == 'string' then copy[b] = TotalCharList[b]
    else for k,v in pairs(b) do copy[k] = v end end
    return meta_copy(a, copy)
end

local function sub_meta(a,b)  -- returns the difference of a and b
    local copy = meta_copy(a)
    if type(b) == 'string' then copy[b] = nil
    else for k,v in pairs(b) do copy[k] = nil end end
    return copy
end

local function mul_meta(a,b)  -- returns the intersection of a and b
    local copy = {}
    for k,v in pairs(a) do
        if b[k] then copy[k] = v end
    end
    setmetatable(copy, getmetatable(a))
    return copy
end

local function unm_meta(a)  -- returns the characters not in a
    local copy = meta_copy(TotalCharList)
    for k in pairs(a) do copy[k] = nil end
    return copy
end

for k,v in pairs({TotalCharList, LetterList, NumberList, HexNumberList, DirectionList, FunctionKeyList}) do
    setmetatable(v, {__add=add_meta, __sub=sub_meta, __mul=mul_meta, __unm=unm_meta})
end


-- Executes and prints strings like an interpreter
function exec(string)
    local func = loadstring("return " .. string)
    if func == nil then func, error = loadstring(string) end
    if func ~= nil then
        local values = {pcall(func)}
        if values[1] then
            if values[2] ~= nil then print(unpack(values, 2)) end
        else print(values[2]) end
    else print(error) end
end


-- Converts a table into a pretty string
function tablestring(data, sort, depth)
    init = data
    local function sort_table(data, depth)
        local copy = {}
        for k,v in pairs(data) do
            if type(v) == "table" and depth > 0 then
                if v == init or v == _G then table.insert(copy, {k})
                else table.insert(copy, {k..":\n", sort_table(v, depth-1)}) end
            else
                table.insert(copy, {k..": "..tostring(v).."\n"})
            end
        end
        if sort then
            table.sort(copy, function (a, b) return a[1] < b[1] end)
        end
        return copy
    end
    local sorted = sort_table(data, depth or math.huge)
    local function get_string(data, depth)
        local s = ""
        for i,v in ipairs(data) do
            s = s .. string.rep(" ", 2*depth) .. v[1]
            if v[2] then 
                s = s .. get_string(v[2], depth+1)
            end
        end
        return s
    end
    return get_string(sorted, 0)
end


-- Checks if cursor is within the boundaries
local function cursorbounds(x1, y1, x2, y2, test1, test2)
    local key = input.get()
    local x, y = key["xmouse"], key["ymouse"]
    if x >= x1 and x <= x2 and y >= y1 and y <= y2 then return true
    else return false end
end


-- Performs a binary search on a sorted array
local function binsearch(array, value)
    local low, high = 1, #array
    if value < array[1] or value > array[#array] then return nil end

    while true do
        local mid = math.floor((low + high)/2)
        local val1, val2 = array[mid], array[mid+1]
        if value >= val1 and value < val2 then
            return mid
        elseif value > val1 then 
            low, high = mid+1, high
        else
            low, high = low, mid-1
        end
        if low == high then return low end
    end
end



-- WIDGET MANAGER --

Widgets = {
    widgets = {},
    hover = {},
    priority = {},
    moving = {},
    selected = {},
    delete = nil,

    -- Adds new widget
    new = function(self, widget)
        local i = 1
        for w in ipairs(self.widgets) do i = i + 1 end
        widget.ID = i
        self.widgets[widget.ID] = widget
        widget.del = function(self) Widgets:del(self) end
        local maxp = 0
        for k,v in pairs(self.priority) do maxp = math.max(maxp, v) end
        self.priority[widget.ID] = maxp + 1
        return widget
    end,

    -- Draws all the widgets
    draw = function(self)
        local key = input.get()
        local clicked = nil
        if key["leftclick"] and not self.lastkey["leftclick"] then clicked = "left" end
        if key["rightclick"] and not self.lastkey["rightclick"] then clicked = "right" end
        local sorted_widgets = {}
        if self.delete then self:del(self.delete); self.delete = nil end
        for ID, pNum in pairs(self.priority) do 
            table.insert(sorted_widgets, {ID, pNum})
        end
        table.sort(sorted_widgets, function(a,b) return a[2] < b[2] end)

        for i, v in ipairs(sorted_widgets) do
            local ID = v[1]
            local widget = self.widgets[ID]
            if not widget.hidden then
                if widget.hover then
                    if clicked then
                        self.selected[ID] = clicked
                        if key["delete"] then self.delete = widget end
                        local i = 0
                        for k,v in pairs(self.priority) do
                            if v > self.priority[ID] then self.priority[k] = v-1 end
                            i = i + 1
                        end
                        self.priority[ID] = i
                    end
                    self.hover[ID] = true
                else 
                    self.hover[ID] = nil
                    if clicked then self.selected[ID] = nil end
                end
                widget:draw()
                self.WidgetMover(self, widget)
            end
        end
        self.lastkey = key
    end,

    -- Handles widget movement
    WidgetMover = function (self, widget)
        local key = input.get()
        local x, y = key["xmouse"], key["ymouse"]
        local ID = widget.ID

        if key["control"] and key["shift"] then
            if key["leftclick"] and not self.lastkey["leftclick"] and (widget.hover or self.moving[ID]) then
                self.moving[ID] = {x-widget.x, y-widget.y}  -- store the *distance* from cursor to coords
            elseif key["rightclick"] and not self.lastkey["rightclick"] and widget.hover then
                self.moving[ID] = false
            end
            if widget.hover then  -- display coords
                local displaystring = tostring(widget.x)..","..tostring(widget.y)
                local xDisplay = math.max(2, math.min(239-4*displaystring:len(), widget.x-12))
                local yDisplay = math.max(2, math.min(152, widget.y-12))
                gui.text(xDisplay, yDisplay, displaystring)
                local i = 2
            end
        else self.moving[ID] = false end

        if self.moving[ID] then
            if key["leftclick"] then
                widget.x = x - self.moving[ID][1]
                widget.y = y - self.moving[ID][2]
            else
                if key["left"] then widget.x = widget.x - 1 end
                if key["right"] then widget.x = widget.x + 1 end
                if key["up"] then widget.y = widget.y - 1 end
                if key["down"] then widget.y = widget.y + 1 end
            end
        end
    end,

    -- Removes widgets
    del = function(self, ID)
        if type(ID) == "table" then ID = ID.ID end
        if self.widgets[ID] then
            for k,v in pairs(self.priority) do
                if v > self.priority[ID] then self.priority[k] = v - 1 end
            end
            for _,t in pairs {self.widgets, self.priority, self.hover, self.moving, self.selected} do
                t[ID] = nil
            end
        end
    end,
}



-------------------
----- WIDGETS -----
-------------------


-- An editable input box that returns its text when you press enter
function InputBox(x, y, charlimit, text, flags)

    x, y = x or 0, y or 0
    charlimit = charlimit or 28
    text = text or ""
    flags = flags or 1  -- 0x1: clear text on enter;  0x2: deselect on enter;  0x4: hide box;  0x8: single color

    local cursorpos = 1
    local lastchar, lastcharhold = "", 0
    local historypos = 1
    local temptext = ""
    local lastkey = {}

    local function draw(self)

        local key = input.get()
        local x, y, charlimit = self.x, self.y, self.charlimit
        if charlimit < 0 then charlimit = self.text:len() + 1 end
        if bit.band(self.flags,1) ~= 0 and self.event then self.text = "" end
        self.event = false
        cursorpos = math.min(self.text:len()+1, math.max(1, cursorpos))

        -- Draws the input box
        if bit.band(self.flags,8) ~= 0 then self.colors_inactive = self.colors_active end
        local tc1, tc2, bc1, bc2 = unpack(self.colors_active)
        local tc3, tc4, bc3, bc4 = unpack(self.colors_inactive)
        local x1, y1, x2, y2 = x, y, x+4*charlimit+4, y+11
        self.hover = cursorbounds(x1, y1, x2, y2)

        -- Draws the text
        if self.active then
            if bit.band(self.flags,4) == 0 then gui.box(x1, y1, x2, y2, bc1, bc2) end
            gui.text(x1+3, y1+2, self.text, tc1, tc2)
            if cursorpos <= charlimit then gui.text(x1+4*cursorpos-1, y1+4, "_") end
        else 
            if bit.band(self.flags,4) == 0 then gui.box(x1, y1, x2, y2, bc3, bc4) end
            gui.text(x1+3, y1+2, self.text, tc3, tc4)
        end

        -- Checks these inputs regardless of writestate
        if key["leftclick"] and not (key["control"] and key["shift"]) then
            if self.hover then 
                cursorpos = math.max(1, math.min(math.floor((key["xmouse"]-x-3)/4), self.text:len())+1)
                self.active = true
            else self.active = false end
        end
        if key["enter"] and not lastkey["enter"] then 
            if self.active and self.text ~= "" then
                self.event = true
                if self.text ~= "" then
                    table.insert(self.history, self.text)
                    historypos = #self.history + 1 
                end
                if bit.band(self.flags,2) ~= 0 then self.active = false end
                if self.func then self.func(self.text) end
            end
        end
        if key["escape"] and not lastkey["escape"] then self.active = false end
        
        -- Only executes when input box is active
        if self.active then
            local shiftstate = 1
            if key["shift"] then shiftstate = 2 end
            for k in pairs(key) do
                if TotalCharList[k] then
                    if k == lastchar then lastcharhold = lastcharhold + 1 end
                    if not lastkey[k] then lastchar, lastcharhold = k, 0 end
                    if not lastkey[k] or (k==lastchar and lastcharhold > 30) then 
                        local char = ""
                        if self.charlist[k] ~= nil then
                            if type(self.charlist[k]) == "table" then char = self.charlist[k][shiftstate]
                            else char = k end
                        end
                        if char:len() == 1 and self.text:len() < charlimit then
                            if LetterList[char:upper()] and key["capslock"] then char = LetterList[char:upper()][2] end
                            self.text = self.text:sub(1,cursorpos-1) .. char .. self.text:sub(cursorpos)
                            cursorpos = cursorpos + 1
                        elseif key["backspace"] and self.text:len() > 0 then
                            if key["control"] then 
                                self.text = self.text:sub(cursorpos, -1)
                                cursorpos = 1
                            else 
                                self.text = self.text:sub(1,math.max(0, cursorpos-2)) .. self.text:sub(cursorpos)
                                cursorpos = cursorpos - 1
                            end
                        elseif key["delete"] and self.text:len() > 0 then
                            if key["control"] then 
                                self.text = self.text:sub(1, cursorpos-1)
                            else 
                                self.text = self.text:sub(1,math.max(0, cursorpos-1)) .. self.text:sub(cursorpos+1, -1)
                            end
                        elseif key["left"] then 
                            if key["control"] then cursorpos = 1
                            else cursorpos = cursorpos-1 end
                        elseif key["right"] then 
                            if key["control"] then cursorpos = charlimit + 1
                            else cursorpos = cursorpos+1 end
                        elseif key["up"] then
                            if historypos > 1 then
                                historypos = historypos - 1
                                if historypos == #self.history then temptext = self.text end
                                self.text = self.history[historypos]
                                cursorpos = charlimit + 1
                            end
                        elseif key["down"] then
                            if historypos <= #self.history then
                                historypos = historypos + 1
                                if historypos <= #self.history then self.text = self.history[historypos]
                                else self.text = temptext; temptext = "" end
                                cursorpos = charlimit + 1
                            end
                        elseif key["home"] then cursorpos = 1
                        elseif key["end"] then cursorpos = charlimit+1
                        end
                    end
                end
            end
        end
        lastkey = key
    end

    return Widgets:new {
        x=x, y=y, charlimit=charlimit, text=text, flags=flags, active=false, charlist=TotalCharList, 
        history={}, class="InputBox", event=false, func=nil, hover=false, draw=draw,
        colors_active={0xFFFFFFFF, 0x000000FF, 0xC0C0C0C0, 0x000000FF},
        colors_inactive={0xC0C0C080, 0x808080FF, 0xC0C0C080, 0x00000040},
    }
end


-- A widget alternative to gui.text
function TextBox(x, y, text, anchor, color1, color2)
    x, y = x or 0, y or 0
    text = text or "text"
    
    local function draw(self)
        local key = input.get()
        local x, y = self.x, self.y
        if self.anchor == 1 then 
            x = x - 2*self.text:len()
        elseif self.anchor == 2 then 
            x = x - 4*self.text:len() 
        end
        self.hover = cursorbounds(x, y, x + 4*self.text:len(), y+8)
        gui.text(x, y, self.text, self.color1, self.color2)
    end

    return Widgets:new {
        x=x, y=y, text=text, color1=color1, color2=color2, anchor=0, 
        class="TextBox", hover=false, draw=draw
    }
end


-- Makes a CheckBox that returns its state when changed
function CheckBox(x,y)
    x, y = x or 0, y or 0
    
    local lastkey = {}
    local function draw(self)
        local key = input.get()
        local x, y = self.x, self.y
        self.event = false
        self.hover = cursorbounds(x, y, x+4, y+4)

        if key["leftclick"] and not lastkey["leftclick"] and self.hover and not (key["control"] and key["shift"]) then
            self.state = not self.state
            self.event = true
            if self.func then self.func(self.state) end
        end
        gui.box(x, y, x+4, y+4, self.colors[2], self.colors[3])
        if self.state then
            if self.style == "x" then
                gui.line(x, y, x+4, y+4, self.colors[1])
                gui.line(x, y+4, x+4, y, self.colors[1])
            elseif self.style == "check" then
                gui.line(x, y+2, x+2, y+4, self.colors[1])
                gui.line(x+2, y+4, x+4, y-2, self.colors[1])
                gui.line(x+2, y+4, x+4, y-1, self.colors[1])
            end
        end
        lastkey = key
    end

    return Widgets:new {
        x=x, y=y, state=false, style="check", class="CheckBox", 
        event=false, func=nil, hover=false, draw=draw,
        colors={0x40FF40FF, 0xC0C0C0FF, 0x000000FF},
    }
end


-- A button that calls func when clicked
function Button(x, y, text, func)
    x, y = x or 0, y or 0
    text = text or "click"
    local lastkey

    local function draw(self)
        local key = input.get()
        local tc1, tc2, bc1, bc2 = unpack(self.colors_unclicked)
        local tc3, tc4, bc3, bc4 = unpack(self.colors_clicked)
        local x1, y1, x2, y2 = self.x, self.y, self.x+4*self.text:len()+2, self.y+8
        self.event = false
        self.hover = cursorbounds(x1, y1, x2, y2)

        if self.hover and key["leftclick"] and not (key["control"] and key["shift"]) and 
            (self.state == true or not lastkey["leftclick"]) then
            gui.box(x1, y1, x2, y2, bc1, bc2)
            gui.text(x1+2, y1+1, self.text, tc1, tc2)
            if not self.state then 
                self.state = true
                self.event = true
                if self.func then self.func() end
            end
        else
            gui.box(x1, y1, x2, y2, bc3, bc4)
            gui.text(x1+2, y1+1, self.text, tc3, tc4)
            if self.state then self.event = true end
            self.state = false
        end
        lastkey = key
    end

    return Widgets:new {
        x=x, y=y, text=text, state=false, class="Button",
        event=false, func=func, hover=false, draw=draw,
        colors_unclicked = {0xFFFFFFE0, 0x000000E0, 0x606060FF, 0xB0B0B0FF},
        colors_clicked = {0xFFFFFFFF, 0x000000FF, 0xC0C0C0FF, 0xA0A0A0FF},
    }
end


-- A group of buttons where only one can be selected; returns the option name when changed
function Radio(x, y, options)
    x, y = x or 0, y or 0
    options = options or {"1"}

    local function draw(self)
        local key = input.get()
        local x, y = self.x, self.y
        local tc1, tc2 = unpack(self.colors_txt)
        local bc1, bc2, bc3, bc4 = unpack(self.colors_rad)
        self.event = false

        local maxlen = 0
        for k,v in pairs(self.options) do
            local bc
            if self.index == k then bc = bc4
                gui.box(x+1, y+2, x+3, y+4, bc1, bc1)
            else bc = bc2
                gui.box(x+1, y+2, x+3, y+4, bc3, bc3)
            end
            gui.line(x+1, y+1, x+3, y+1, bc)
            gui.line(x+1, y+5, x+3, y+5, bc)
            gui.line(x, y+2, x, y+4, bc)
            gui.line(x+4, y+2, x+4, y+4, bc)
            gui.text(x+8, y, v, tc1 , tc2)
            maxlen = math.max(maxlen, v:len())
            if key["leftclick"] and cursorbounds(x, y, x+4, y+7) and not (key["control"] and key["shift"]) then
                if k ~= self.index then 
                    self.event = true
                    self.index = k
                    self.value = v
                    if self.func then self.func(v) end
                end
            end
            y = y + 10
        end
        self.hover = cursorbounds(self.x, self.y, x+4*maxlen+8, y-2)
    end

    return Widgets:new {
        x=x, y=y, options=options, index=0, value="", 
        class="Radio", event=false, func=nil, hover=false, draw=draw,
        colors_txt = {0xFFFFFFFF, 0x000000FF}, 
        colors_rad = {0x404040FF, 0x000000FF, 0xC0C0C0FF, 0x303030FF},
    }
end


-- An adjustable slider; Orientation may be 'v' or 'h' for vertical/horizontal
function Slider(x, y, left, right, step, orientation, length)
    x, y = x or 2, y or 5
    left, right = left or 0, right or 10
    step = step or 1
    orientation = orientation or "h"
    length = length or 50
    local sliderPos = x

    local function draw(self)
        local key = input.get()
        local x, y, left, right, step, length, ori = 
            self.x, self.y, self.left, self.right, self.step, self.length, self.orientation
        local linec, bc1, bc2 = self.color_line, unpack(self.color_slide)
        if not key["leftclick"] then self.drag = false end
        self.event = false

        if ori == "h" then 
            gui.line(x, y, x+length, y, linec)
            self.hover = cursorbounds(x-2, y-4, x+length+2, y+4)
        elseif ori == "v" then 
            gui.line(x, y, x, y+length, linec)
            self.hover = cursorbounds(x-4, y-2, x+4, y+length+2)
        end

        if self.drag then
            local initvalue = self.value
            -- round value to nearest multiple of step based on cursor
            if ori == "h" then
                self.value = step*math.floor((key["xmouse"]-sliderPos) / length * (right-left) / step + 0.5) + self.value
            elseif ori == "v" then 
                self.value = step*math.floor((key["ymouse"]-sliderPos) / length * (right-left) / step + 0.5) + self.value
            end
            
            if self.value ~= initvalue then 
                self.event = true
                if self.func then self.func(self.value) end
            end
        end

        min, max = math.min(left, right), math.max(left, right)
        if self.value < min then self.value = min
        elseif self.value > max then self.value = max
        end

        if ori == "h" then
            if right == left then sliderPos = x + length/2
            else sliderPos = (self.value-left) / (right-left) * length + x end
            gui.box(sliderPos-2, y-4, sliderPos+2, y+4, bc1, bc2)
            if key["leftclick"] and cursorbounds(sliderPos-2, y-4, sliderPos+2, y+4) then
                self.drag = true
            end
        elseif ori == "v" then 
            if right == left then sliderPos = y + length/2
            else sliderPos = (self.value-left) / (right-left) * length + y end
            gui.box(x-4, sliderPos-2, x+4, sliderPos+2, bc1, bc2)
            if key["leftclick"] and cursorbounds(x-4, sliderPos-2, x+4, sliderPos+2) then
                self.drag = true
            end
        end
    end

    return Widgets:new {
        x=x, y=y, left=left, right=right, step=step, orientation=orientation, 
        length=length, value=0, drag=false, class="Slider", 
        event=false, func=nil, hover=false, draw=draw,
        color_line = 0x000000FF, color_slide = {0xC0C0C0FF, 0x000000FF},
    }
end


-- A window for displaying text data; data may be a string or a table
function Window(x, y, data, charwidth, charheight)

    x, y = x or 0, y or 0
    data = data or ""
    charwidth = charwidth or 20
    charheight = charheight or 10
    local lastkey = {}
    local clickstate, clickhold = false, 0
    local maxh_index, maxv_index
    local linePositions
    local datastring


    local function newtext(newdata)  -- parses data and updates maxv_index, maxh_index, linePositions, and datastring
        newdata = newdata or ""
        if type(newdata) == "function" then newdata = newdata() end
        if type(newdata) == "table" then newdata = tablestring(newdata, true, 1) 
        elseif type(newdata) == "number" then newdata = tostring(newdata) end
        if datastring ~= newdata then
            linePositions = {1}
            local maxlen = 0
            for line in newdata:gmatch("[^\r\n]*\n?") do
                table.insert(linePositions, (linePositions[#linePositions] or 0) + line:len())
                maxlen = math.max(maxlen, line:len())
            end
            maxv_index = #linePositions - charheight + 1
            maxh_index = maxlen - charwidth + 2
            datastring = newdata
        end
    end

    newtext(data)

    local function draw(self)
        local key = input.get()
        if not key["leftclick"] then
            clickstate, clickhold = false, 0
            self.drag_h = false
            self.drag_v = false 
        elseif clickstate then
            clickhold = clickhold + 1
        end
        if (data ~= self.data) or self.auto_update then data = self.data;  newtext(self.data) end
        local x1, y1, x2, y2 = self.x, self.y, self.x+4*self.charwidth+4, self.y+9*self.charheight+2
        local charwidth, charheight = self.charwidth, self.charheight
        local text_c1, text_c2 = unpack(self.colors_txt)
        local window_c1, window_c2 = unpack(self.colors_window)
        local scroll_c1, scroll_c2, scroll_c3 = unpack(self.colors_scroll)
        
        -- Draws the Window
        gui.box(x1, y1, x2, y2, window_c1, window_c2)  -- text box
        
        if maxv_index > 1 then
            gui.box(x2, y1, x2+6, y2, scroll_c2, scroll_c3)  -- outer vertical scroll box
            gui.line(x2, y1+5, x2+6, y1+5, scroll_c3)
            gui.line(x2, y2-5, x2+6, y2-5, scroll_c3)
            gui.line(x2+2, y1+3, x2+4, y1+3, scroll_c3); gui.pixel(x2+3, y1+2, scroll_c3)
            gui.line(x2+2, y2-3, x2+4, y2-3, scroll_c3); gui.pixel(x2+3, y2-2, scroll_c3)
        end

        if maxh_index > 1 then
            gui.box(x1, y2, x2, y2+6, scroll_c2, scroll_c3)  -- outer horizontal scroll box
            gui.line(x1+5, y2, x1+5, y2+6, scroll_c3)
            gui.line(x2-5, y2, x2-5, y2+6, scroll_c3)
            gui.line(x1+3, y2+2, x1+3, y2+4, scroll_c3); gui.pixel(x1+2, y2+3, scroll_c3)
            gui.line(x2-3, y2+2, x2-3, y2+4, scroll_c3); gui.pixel(x2-2, y2+3, scroll_c3)
        end
        
        -- Displays the text
        local x, y = self.x+3, self.y+2
        for i=self.index, math.min(#linePositions-1, self.index+charheight-1) do
            line = datastring:sub(linePositions[i], (linePositions[i+1] or 0) - 1)
            line = line:sub(self.index_h):sub(1,charwidth)
            if i == self.highlight then gui.box(x1+2, y-1, x2-2, y+7, 0x8080FFFF) end
            gui.text(x, y, line, text_c1, text_c2)
            y = y + 9
        end
        
        -- Index Calculation
        local x1_v, y1_v = x2+3, y1+10  -- edge of vertical scroll region
        local x1_h, y1_h = x1+10, y2+3  -- edge of horizontal scroll region
        if self.drag_v == true then
            self.index = math.floor((key["ymouse"]-y1_v) / (y2-y1-20) * (maxv_index-1) + 0.5) + 1
        end
        if self.drag_h == true then
            self.index_h = math.floor((key["xmouse"]-x1_h) / (x2-x1-20) * (maxh_index-1) + 0.5) + 1
        end

        -- Boundary Check
        self.index = math.max(1, math.min(maxv_index, self.index))
        self.index_h = math.max(1, math.min(maxh_index, self.index_h))

        -- Position Calculation
        local scroll_v = (self.index-1) / (maxv_index-1) * (y2-y1-20)  -- position of vertical scrollbar relative to lowest point
        local scroll_h = (self.index_h-1) / (maxh_index-1) * (x2-x1-20)  -- position of horizontal scrollbar relative to lowest point
        if maxv_index > 1 then gui.box(x1_v-1, y1_v+scroll_v-3, x1_v+1, y1_v+scroll_v+3, scroll_c1, scroll_c1) end
        if maxh_index > 1 then gui.box(x1_h+scroll_h-3, y1_h-1, x1_h+scroll_h+3, y1_h+1, scroll_c1, scroll_c1) end

        -- Click Checks
        if key["leftclick"] and not (key["control"] and key["shift"]) then
            if cursorbounds(x1_v-2, y1_v+scroll_v-3, x1_v+2, y1_v+scroll_v+3) then  -- vertical scroll handle
                self.drag_v = true
            elseif cursorbounds(x1_h+scroll_h-3, y1_h-2, x1_h+scroll_h+3, y1_h+2) then  -- horizontal scroll handle
                self.drag_h = true
            elseif (not lastkey["leftclick"] or clickhold > 30) and not(self.drag_v or self.drag_h) then
                if cursorbounds(x1, y1, x2, y2) then
                    self.highlight = math.max(1, math.min(#linePositions-1, self.index + math.floor((key["ymouse"] - (self.y+1))/9)))
                elseif not self.hover then
                    self.highlight = nil
                end
                local direction = 1
                if cursorbounds(x2, y1, x2+6, y2) then  -- hovering over vertical scroll bar
                    clickstate = true
                    local y = key["ymouse"]
                    if y < y1_v+scroll_v then direction = -1 end
                    if y >= y1+5 and y <= y2-5 then
                        local maxchange = math.floor(math.abs(y1_v+scroll_v-y) / (y2-y1-20) * (maxv_index-1) + 0.5)
                        self.index = self.index + direction*math.min(charheight, maxchange)
                    else
                        self.index = self.index + direction
                    end
                    self.index = math.max(1, math.min(maxv_index, self.index)) 
                elseif cursorbounds(x1, y2, x2, y2+6) then  -- hovering over horizontal scroll bar
                    clickstate = true
                    local x = key["xmouse"]
                    if x < x1_h+scroll_h then direction = -1 end
                    if x >= x1+5 and x <= x2-5 then 
                        local maxchange = math.floor(math.abs(x1_h+scroll_h-x) / (x2-x1-20) * (maxh_index-1) + 0.5)
                        self.index_h = self.index_h + direction*math.min(5, maxchange)
                    else
                        self.index_h = self.index_h + direction
                    end
                    self.index_h = math.max(1, math.min(maxh_index, self.index_h))
                end
            end
        end

        if self.highlight then
            self.line = datastring:sub(linePositions[self.highlight] or 1, (linePositions[self.highlight+1] or 0)-1):match("%s*([^\n]*)")
        end
        self.hover = cursorbounds(x1, y1, x2+6, y2+6)
        if key["escape"] and self.hover then self.highlight = nil end

        for k,v in pairs(self.embedded) do
            local widget, relx, rely = unpack(v)
            widget.x = relx + self.x
            widget.y = rely + self.y
            widget:draw()
            if widget.hover then self.hover = true end
        end
        lastkey = key
    end

    local function search(self, string, start)
        local pos = datastring:find(string:sub(start or 1))
        if pos then 
            self.index = binsearch(linePositions, pos) or 1 
            self.highlight = self.index
        end
    end

    local function embed(self, widget)
        table.insert(self.embedded, {widget, widget.x-self.x, widget.y-self.y})
        Widgets:del(widget)
    end

    local function detach(self, widget)
        for k,v in pairs(self.embedded) do
            if v[1] == widget then self.embedded[k] = nil end
        end
        Widgets:new(widget)
    end

    return Widgets:new {
        x=x, y=y, data=data, charwidth=charwidth, charheight=charheight, auto_update=true,
        index=1, index_h=1, highlight=nil, line="", embedded={}, embed=embed, detach=detach, 
        drag_v=false, drag_h=false, class="Window", event=false, func=nil, hover=false, draw=draw, search=search,
        colors_window = {0xC0C0C0C0, 0x00000FF}, 
        colors_scroll = {0x808080FF, 0xE0E0E0FF, 0x00000FF},
        colors_txt = {0xFFFFFFFF, 0x000000FF},
    }
end


function Canvas(x, y, width, height)
    
    x, y = x or 0, y or 0
    width, height = width or 100, height or 100
    local bitmap
    local lastkey
    local prevx, prevy
    local modes = {"pencil", "brush", "line", "box"}
    local mode_drawings = {
        function(x,y) gui.pixel(x+4, y+4, 0x000000FF) end,
        function(x,y) 
            gui.line(x+3, y+4, x+5, y+4, 0x000000FF)
            gui.line(x+4, y+3, x+4, y+5, 0x000000FF)
        end,
        function(x,y) gui.line(x+2, y+6, x+6, y+2, 0x000000FF) end,
        function(x,y) gui.box(x+2, y+2, x+6, y+6, 0, 0x000000FF) end,
        function(x,y) 
            gui.line(x+2, y+2, x+2, y+6, 0x000000FF)
            gui.line(x+2, y+6, x+6, y+6, 0x000000FF)
            gui.line(x+6, y+6, x+6, y+2, 0x000000FF)
        end,
    }
    local mode_click = false
    local temp
    local background_color = 0xFFFFFFFF

    local function draw(self)
        local key = input.get()
        if key["control"] and key["shift"] then key["leftclick"] = nil end
        if width ~= self.width or height ~= self.height or bitmap ~= self.bitmap then
            self.bitmap = {}
            for i=1,self.width do table.insert(self.bitmap, {}) end
            width = self.width
            height = self.height
            bitmap = self.bitmap
        end
        local x1, y1, x2, y2 = self.x, self.y, self.x+self.width+1, self.y+self.height+1
        local color = self.color
        local mode = self.mode

        -- Main Box
        gui.box(x1, y1, x2, y2, background_color, 0x000000FF)

        -- Mode options
        local mode_pos = {}
        local offset = 0
        for i=1,#modes+1 do
            gui.box(x1+offset, y1-16, x1+offset+8, y1-8, 0xFFFFFFFF, 0x000000FF)
            mode_drawings[i](x1+offset, y1-16)
            offset = offset + 10
        end
        if key["leftclick"] and cursorbounds(x1, y1-16, x1+10*#modes+8, y1-8) then
            local mode_index = math.floor((key["xmouse"] - x1)/10)+1
            if not lastkey["leftclick"] then
                mode_click = mode_index
                if mode_index <= #modes then self.mode = modes[mode_index]
                else self:clear() end
            end
            if mode_click == mode_index then 
                gui.box(x1+mode_index*10-10, y1-16, x1+8+mode_index*10-10, y1-8, "#00000040")
            end
        else mode_click = false
        end

        -- Palette
        for i=1,#self.palette do
            gui.box(x1+5*i-5, y1-6, x1+5*i-1, y1-2, self.palette[i], self.palette[i])
        end
        if key["leftclick"] and not lastkey["leftclick"] and cursorbounds(x1, y1-6, x1+5*#self.palette, y1-2) then
            self.color = self.palette[math.floor((key["xmouse"] - x1)/5) + 1]
        end

        -- Draws the bitmap to the screen
        for x,column in pairs(bitmap) do
            for y, color in pairs(column) do
                gui.pixel(x+x1, y+y1, color)
            end
        end

        -- Drawing Area
        if cursorbounds(x1+1, y1+1, x2-1, y2-1) then
            gui.pixel(key["xmouse"], key["ymouse"], color)
            local edgeguard = 0
            if mode == "brush" then 
                edgeguard = 1
                gui.line(key["xmouse"]-1, key["ymouse"], key["xmouse"]+1, key["ymouse"], color)
                gui.line(key["xmouse"], key["ymouse"]-1, key["xmouse"], key["ymouse"]+1, color)
            end
            local relx = math.min(width-edgeguard, math.max(1+edgeguard, key["xmouse"]-x1))
            local rely = math.min(height-edgeguard, math.max(1+edgeguard, key["ymouse"]-y1))
            if prevx == nil or prevy == nil then prevx, prevy = relx, rely end
            if temp then
                if mode == "line" then gui.line(prevx+x1, prevy+y1, relx+x1, rely+y1, color)
                elseif mode == "box" then gui.box(prevx+x1, prevy+y1, relx+x1, rely+y1, 0x00000000, color)
                end
            end
            if key["leftclick"] then
                if not lastkey["leftclick"] then prevx, prevy = relx, rely end
                if mode == "pencil" then
                    self:line(prevx, prevy, relx, rely, color)
                    prevx, prevy = relx, rely
                elseif mode == "brush" then
                    self:line(prevx, prevy, relx, rely, color)
                    self:line(prevx-1, prevy, relx-1, rely, color)
                    self:line(prevx+1, prevy, relx+1, rely, color)
                    self:line(prevx, prevy-1, relx, rely-1, color)
                    self:line(prevx, prevy+1, relx, rely+1, color)
                    prevx, prevy = relx, rely
                elseif mode == "line" then
                    temp = true
                elseif mode == "box" then
                    temp = true
                end
            elseif temp then
                if mode == "line" then
                    self:line(prevx, prevy, relx, rely, color)
                elseif mode == "box" then
                    self:line(prevx, prevy, relx, prevy, color)
                    self:line(relx, prevy, relx, rely, color)
                    self:line(relx, rely, prevx, rely, color)
                    self:line(prevx, rely, prevx, prevy, color)
                end
                temp = nil
            end
        end

        self.hover = cursorbounds(x1, y1, x2, y2) or cursorbounds(x1, y1-16, x1+5*#self.palette, y1)
        if not key["leftclick"] then temp, prevx, prevy = nil, nil, nil end
        lastkey = key
    end

    local function line(self, x1, y1, x2, y2, color)
        if color == background_color then color = nil end
        local bitmap = self.bitmap
        local xdir, ydir = 1,1
        if x2 < x1 then xdir = -1 end
        if y2 < y1 then ydir = -1 end
        if x2 == x1 then
            for i=y1,y2,ydir do
                bitmap[x2][i] = color
            end
        elseif y2 == y1 then
            for i=x1,x2,xdir do
                bitmap[i][y2] = color
            end
        else
            local slope1 = (y2-y1)/(x2-x1)
            local slope2 = (x2-x1)/(y2-y1)
            for i=0, x2-x1, xdir do
                bitmap[x1+i][y1+math.floor(i*slope1+0.5)] = color
            end
            for i=0, y2-y1, ydir do
                bitmap[x1+math.floor(i*slope2+0.5)][y1+i] = color
            end
        end
    end

    local function clear(self)
        for k,v in pairs(self.bitmap) do 
            self.bitmap[k] = {}
        end
    end

    return Widgets:new {
        x=x, y=y, width=width, height=height, bitmap={}, mode="pencil",
        palette={0x000000FF, 0xFFFFFFFF, 0x808080FF, 0xED1C24FF, 0xFF7F27FF, 
            0xFFF200FF, 0x22B14CFF, 0x00A2E8FF, 0x3F48CCFF, 0xA349A4FF}, color=0x000000FF,
        line=line, clear=clear, class="Canvas", hover=false, draw=draw
    }
end